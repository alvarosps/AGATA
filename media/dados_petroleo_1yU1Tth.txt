Objeto	na ordem de giro|X ; Y; Z; Angulos (iniciais);				|X; Y; Z; Angulos (finais);	 |Variações
1			|Z 135º 						|Z 160º				 |varZº = +25º
2			|X 55.9078m ; Z 24.3614m ; Z 270º			|X 55.3420m ; Z 24.8156m ; Z 247º|varXm = -0.5658m ; varZm = +0.4542 ; varZº -23º
3			|Y 26.50º						|Y 23º				 |varYº = -3.5º
4			|X 33.5807m ; Z 35.4951m 				|X 33.3199m ; Z 34.6733m	 |varXm = -0.2608m ; varZm = -0.8218m

Funções:
Base:
default{
    state_entry (){
        llListen(333, "","","");
    }
    listen (integer channel, string name, key id, string message ){
    if(message==""){
        
    }
    }
}

-------------------------------------------------------------------------
Rotação:
llSetRot(llGetRot() * llEuler2Rot(<0,0,angulo>*DEG_TO_RAD));
-------------------------------------------------------------------------
Mover posição:
llSetPos(llGetPos()+<0,0,Z>)
llSetPos(llGetPos()+<X, 0, 0>) -> + se for para trás, - se for para frente
-------------------------------------------------------------------------
Delay:
llSleep(tempo); em segundos
-------------------------------------------------------------------------
Definição do número de intervalos:
->Temos 25, 0.5658, 0.4542, 23, 3.5, 0.2608, 0.8218
->Vamos dividir todos por 50, com 0.05 segundos entre cada

Objeto 1:
rotaciona_objeto1(float varAngZ, integer num_div, float tempo_intervalo){
	//Variaveis de contagem dos loops
	integer loop_count1;
	integer loop_count2;
	//Variaveis do movimento
	float numDiv = (num_div/1.0);
	float deltaAngZ = (varAngZ/numDiv);
	//Primeira rotacao(ida)
  	do {
  		llSetRot(llGetRot() * llEuler2Rot(<0,0,deltaAngZ>*DEG_TO_RAD));
		llSleep(tempo_intervalo)
	} while(++loop_count1 < num_div);
	//Segunda rotacao(volta)
  	do {
  		llSetRot(llGetRot() * llEuler2Rot(<0,0,-deltaAngZ>*DEG_TO_RAD));
		llSleep(tempo_intervalo)
	} while(++loop_count2 < num_div);
}
default{
    state_entry (){
        llListen(333, "","","");
    }
    listen (integer channel, string name, key id, string message ){
    if(message=="teste"){
        integer numero_divisoes = 50;
	float tempo = 0.05;
	float varAngZ = 25.0;
	rotaciona_objeto1(varAngZ, numero_divisoes, tempo);
    }
    }
}

Objeto 2:
varXm = -0.5658m ; varZm = +0.4542 ; varZº -23º
rotaciona_objeto2(float varX, float varZ, float varAngZ, integer num_div, float tempo_intervalo){
	//Variaveis de contagem dos loops
	integer loop_count1;
	integer loop_count2;
	//Variaveis do movimento
	float numDiv = (num_div/1.0);
	float deltaX = (varX/numDiv);
	float deltaZ = (varZ/numDiv);
	float deltaAngZ = (varAngZ/numDiv);
	//Primeira rotacao(ida)
  	do {
  		llSetRot(llGetRot() * llEuler2Rot(<0,deltaAngZ,0>*DEG_TO_RAD));
		llSetPos(llGetPos()+<-deltaX, 0, 0>);
		llSetPos(llGetPos()+<0,0,deltaZ>);
		llSleep(tempo_intervalo);
	} while(++loop_count1 < num_div);
	//Segunda rotacao(volta)
  	do {
  		llSetRot(llGetRot() * llEuler2Rot(<0,-deltaAngZ,0>*DEG_TO_RAD));
		llSetPos(llGetPos()+<deltaX, 0, 0>);
		llSetPos(llGetPos()+<0,0,-deltaZ>);
		llSleep(tempo_intervalo);
	} while(++loop_count2 < num_div);
}